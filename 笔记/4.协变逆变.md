# 协变、逆变、双变和抗变的理解？

1. 协变：X=Y Y类型可以赋值给X类型的情况。也可以说是X类型兼容Y类型

```javascript
interface X { name: string; age: number; } 
interface Y { name: string; age: number; hobbies: string[] }
let x: X = { name: 'xiaoming', age: 16 }
let y: Y = { name: 'xiaohong', age: 18, hobbies: ['eat'] }
x = y

```
相当于是Y继承了X，Y赋值给X，就是协变（X是父类，Y是子类）

子类（成员多）给父类（成员少）

2. 逆变：methodY=methodX 函数X类型可以赋值给函数Y类型，因为函数Y在调用的时候参数是按照Y类型进行约束的，但是用到的是函数X的属性和方法。

```javascript
let methodY: (y: Y) => void
methodY = (y) => { console.log(y.hobbies) }

let methodX: (x: X) => void
methodX = (x) => { console.log(x.name) }
// 正确
methodY = methodX

```

按照上面协变的说话，子类型多，父类型少，那么子类型给父类型是没问题。
但是这里注意，接受的是函数参数
```
// 错误
methodX = methodY

// 假如上面的执行了,methodX应该接收一个父类型的数据
methodX(X)
// 但是methodX真正调用的时候，他是什么？ 是methodY函数，methodY函数要求的是传入X类型的数据，所以会报类型错误
```



3. 双变（双向协变）：X = Y；Y = X 
   
   父类型可以赋值给子类型，子类型可以赋值给父类型，既逆变又协变。
   在TS的早期版本中，函数参数类型是双变的。
  （ts2.x 之前支持这种赋值，之后 ts 加了一个编译选项 strictFunctionTypes，设置为 true 就只支持**函数参数**的逆变，设置为 false 则支持双向协变）

  **逆变(Contravariance)与双变(Bivariance)只针对函数有效。**

4. 抗变（不变）：**非父子类型**之间不会发生型变，只要类型不一样就会报错.